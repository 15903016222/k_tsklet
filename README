tsklet
 
4.linux内核中断编程之顶半部和底半部机制
  4.1.明确相关概念
  linux系统,CPU软件层面一天到晚做两类事：进程和中断,哪个要想运行,必须先获取到CPU资源
  “任务”：包括进程和中断
  “休眠”：仅存在进程的世界里,进程休眠只是当前进程会释放所占用的CPU资源给
          其他任务使用,中断是不允许休眠操作
  “优先级”：衡量一个任务获取CPU的一种能力,优先级越高,获取CPU资源的能力就越强
  中断分两类：硬件中断和软中断
  中断不隶属于任何进程,不参与进程之间的调度
  前提是在linux系统,任务优先级的划分：
  硬件中断优先级大于软中断
  软中断的优先级大于进程
  软中断有优先级之分
  进程有优先级之分
  硬件中断无优先级之分
  
  4.2.切记：linux内核要求中断处理函数的执行速度越快越好,其他
      任务就能够及时获取到CPU资源
      注意：中断处理函数更不能做休眠操作
      如果中断处理函数长时间占用CPU资源,会影响系统的并发能力
      和响应能力！
      
      问：有些场合,中断处理函数势必会长时间占用CPU资源
          也会势必影响系统的并发和响应能力,怎么办？
      答：通过中断编程之顶半部和底半部机制进行优化
  	  将原先的中断处理函数一分为二,分别是顶半部和
  	  底半部
  
  4.3.顶半部特点
  本质上就是中断处理函数,也就是一旦硬件产生中断,内核首先
  执行顶半部的内容(内核首先调用中断处理函数)；
  此时的中断处理函数和原中断处理函数不一样,此时的中断处理函数
  会做原先中断处理函数中比较紧急,耗时较短的内容,一旦执行完毕
  快速释放CPU资源给其他任务使用！
  
  顶半部执行期间不允许被打断,不允许发生CPU资源的切换！
  
  4.4.底半部特点
  底半部要执行原先中断处理函数中不紧急,耗时较长的内容;
  CPU会在"适当的时候"会去执行底半部的内容;
  由于它不紧急,所以如果来了高优先级的任务同样可以打断底半部的
  执行过程,允许CPU资源发生切换
  
  4.5.底半部实现方法：三种
      tasklet
      工作队列
      软中断
  
  4.6.底半部机制之tasklet特点
  1.本质就是延后执行的一种手段
  2.tasklet对应的延后处理函数,此函数中原先中断处理函数中
    不紧急,耗时较长的内容
  3.tasklet是基于软中断实现,优先级高于进程,低于硬件中断
    所以tasklet延后处理函数不能进行休眠操作
  4.tasklet的数据结构
    struct tasklet_struct {
    	void (*function)(unsigned long data);
    	unsigned long data;
    	...
    };
    成员：
    function:tasklet的延后处理函数,做不紧急,耗时较长的内容
             不能进行休眠操作
             形参data保存是给延后处理函数传递的参数,一般传递
             参数的指针,注意数据类型的转换
    data：就是给延后处理函数传递的参数
    
    配套函数：
    DECLARE_TASKLET(name,func,data);
    功能：定义初始化tasklet对象
    name:tasklet对象名
    func:tasklet延后处理函数地址
    data:给延后处理函数传递的参数
    
    tasklet_schedule(&tasklet对象);
    功能：向内核登记tasklet延后处理函数,一旦登记完成,内核
          会在"适当的时候"去执行对应的延后处理函数	
    如果驱动中有顶半部(中断处理函数),一般在顶半部的代码中
    调用登记即可；
    如果驱动中没有顶半部,依据实际的硬件操作需求进行调用登记
    即可！
    一旦登记完成,内核就会在适当的时候去执行！
     
    最后编写好延后处理函数即可
    
    切记：tasklet基于软中断实现,所以延后处理函数执行速度尽量快
          更不能做休眠操作
          
    案例：利用tasklet"优化"按键驱动
 
